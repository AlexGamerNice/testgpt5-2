
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>P2P Chess (GitHub Pages)</title>
  <link rel="stylesheet" href="https://unpkg.com/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" />
  <style>
    body{font-family:Inter,ui-sans-serif,system-ui,Arial;margin:0;background:#0f172a;color:#e6eef8}
    .wrap{max-width:980px;margin:28px auto;padding:20px}
    header{display:flex;align-items:center;gap:16px}
    h1{margin:0;font-size:20px}
    .board-row{display:flex;gap:20px;margin-top:18px}
    #board{width:520px}
    .panel{flex:1;background:#071029;padding:14px;border-radius:10px;box-shadow:0 6px 20px rgba(2,6,23,.6)}
    .small{font-size:13px;color:#9fb4d8}
    textarea{width:100%;height:86px;background:#062033;border:1px solid #113; color:#dff0ff;padding:8px;border-radius:6px}
    input[type=button],button{background:#0ea5a3;border:0;padding:8px 10px;border-radius:8px;color:white;cursor:pointer}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .row{display:flex;gap:8px;margin-top:8px}
    .muted{color:#88a6c3}
    .log{height:120px;overflow:auto;background:#03121b;padding:8px;border-radius:6px;border:1px solid #072233;color:#9fd8ff}
    label{display:block;font-size:13px;margin-bottom:6px}
    .tiny{font-size:12px;color:#7fb0d8}
    .copybtn{background:#1e293b}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>P2P Chess — Host on GitHub Pages (no server)</h1>
      <div class="small">Manual WebRTC signalling via copy-paste. Works in modern browsers.</div>
    </header>

    <div class="board-row">
      <div id="board" class="panel"></div>

      <div class="panel">
        <div><strong>Game</strong> <span class="muted">(click a piece, then a target square)</span></div>
        <div class="row">
          <button id="newBtn">New Game</button>
          <button id="undoBtn">Undo</button>
          <button id="flipBtn">Flip Board</button>
        </div>
        <div class="row" style="margin-top:10px">
          <label class="tiny">Play as</label>
          <select id="playAs">
            <option value="both">Both (observe)</option>
            <option value="white">White</option>
            <option value="black">Black</option>
          </select>
        </div>

        <div style="margin-top:12px">
          <label class="tiny">Connection / Signalling (copy-paste SDP)</label>
          <div style="display:flex;gap:6px;margin-bottom:6px">
            <button id="createOffer">Create Offer</button>
            <button id="createAnswer" disabled>Set Remote (and create Answer)</button>
            <button id="setRemoteFinal" disabled>Set Remote (finalize)</button>
          </div>
          <textarea id="localSDP" readonly placeholder="Local SDP will appear here"></textarea>
          <div style="margin:8px 0" class="tiny muted">Paste the remote SDP below and click the appropriate button</div>
          <textarea id="remoteSDP" placeholder="Paste remote SDP here"></textarea>
          <div class="controls" style="margin-top:8px">
            <button id="copyLocal">Copy Local</button>
            <button id="clearSDP">Clear</button>
          </div>
        </div>

        <div style="margin-top:10px">
          <label class="tiny">Connection log</label>
          <div id="log" class="log"></div>
        </div>

      </div>
    </div>

    <footer style="margin-top:18px;color:#9fb4d8;font-size:13px">Tip: for quicker pairing, use a chat app to exchange the SDP blobs, or use a temporary signalling server if you add one to the code.</footer>
  </div>

  <!-- libs -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://unpkg.com/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
  <script src="https://unpkg.com/chess.js@1.0.0-beta.0/dist/chess.js"></script>

  <script>
    // Basic chess + UI glue
    const cfg = { draggable: true, position: 'start', onDrop: onDrop, onSnapEnd: onSnapEnd }
    const board = Chessboard('board', cfg)
    const game = new Chess()
    const logEl = document.getElementById('log')
    function log(s){ logEl.innerText += '\n' + s; logEl.scrollTop = logEl.scrollHeight }

    // Controls
    document.getElementById('newBtn').onclick = ()=>{ game.reset(); board.start(); sendState() }
    document.getElementById('undoBtn').onclick = ()=>{ game.undo(); board.position(game.fen()); sendState() }
    document.getElementById('flipBtn').onclick = ()=>{ board.flip() }

    function onDrop(source, target, piece, newPos, oldPos, orientation){
      const move = game.move({ from: source, to: target, promotion: 'q' })
      if (move === null) return 'snapback'
      board.position(game.fen())
      log('Local move: ' + move.san)
      // send move to remote
      sendMessage({ t: 'move', m: move })
      return undefined
    }
    function onSnapEnd(){ board.position(game.fen()) }

    // Sync helpers
    function applyRemoteMove(m){
      // m is the move object from chess.js
      try{
        game.move({from:m.from, to:m.to, promotion: m.promotion || 'q'})
        board.position(game.fen())
        log('Remote move: ' + (m.san || (m.from+'-'+m.to)))
      }catch(e){ log('Failed to apply remote move: ' + e) }
    }
    function sendState(){ sendMessage({ t:'state', fen: game.fen() }) }

    // --- WebRTC DataChannel (manual signalling) ---
    let pc = null
    let dc = null
    const offerBtn = document.getElementById('createOffer')
    const answerBtn = document.getElementById('createAnswer')
    const finalizeBtn = document.getElementById('setRemoteFinal')
    const localSDP = document.getElementById('localSDP')
    const remoteSDP = document.getElementById('remoteSDP')

    function makePeerConnection(isOfferer=false){
      pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]})
      pc.onicecandidate = e=>{
        if(!e.candidate) {
          // signalling complete
          localSDP.value = btoa(unescape(encodeURIComponent(JSON.stringify(pc.localDescription))))
          log('Local SDP ready (base64)')
        }
      }
      pc.ondatachannel = e=>{
        dc = e.channel
        setupDC()
      }
      pc.onconnectionstatechange = ()=>{ log('Connection state: '+pc.connectionState) }
      // create data channel if we're the offerer
      if(isOfferer){
        dc = pc.createDataChannel('chess')
        setupDC()
      }
    }

    function setupDC(){
      if(!dc) return
      dc.onopen = ()=>{ log('DataChannel open'); enableControls(true); sendState() }
      dc.onclose = ()=>{ log('DataChannel closed'); enableControls(false) }
      dc.onmessage = ev=>{
        try{
          const obj = JSON.parse(ev.data)
          handleMessage(obj)
        }catch(e){ log('Bad message: '+e) }
      }
    }

    function handleMessage(obj){
      if(obj.t==='move') applyRemoteMove(obj.m)
      else if(obj.t==='state'){
        try{ game.load(obj.fen); board.position(game.fen()); log('Remote sent state') } catch(e){ log('Bad state from remote') }
      }else if(obj.t==='chat') log('[remote] '+obj.msg)
    }

    function sendMessage(obj){
      if(dc && dc.readyState === 'open'){
        dc.send(JSON.stringify(obj))
      }
    }

    function enableControls(enabled){
      // When connected, local moves are allowed if playAs permits
      document.getElementById('newBtn').disabled = !enabled
      document.getElementById('undoBtn').disabled = !enabled
    }

    // Buttons: Create Offer
    offerBtn.onclick = async ()=>{
      makePeerConnection(true)
      const offer = await pc.createOffer()
      await pc.setLocalDescription(offer)
      log('Created offer — waiting for ICE to gather, then paste Local SDP to share')
      // localSDP will be filled when icecandidate null fires
      createAnswer.disabled = false
      finalizeBtn.disabled = false
    }

    // Buttons: Set Remote & create Answer (this is used by the second peer who received an Offer)
    createAnswer.onclick = async ()=>{
      try{
        const remote = JSON.parse(decodeURIComponent(escape(atob(remoteSDP.value))))
        makePeerConnection(false)
        await pc.setRemoteDescription(remote)
        const answer = await pc.createAnswer()
        await pc.setLocalDescription(answer)
        log('Created answer — waiting for ICE to gather')
        // answer SDP will appear in localSDP when ICE gathering finishes
      }catch(e){ log('Bad remote SDP or error: '+e) }
    }

    // Buttons: Set remote final (used by the original offerer to paste the answer)
    finalizeBtn.onclick = async ()=>{
      try{
        const remote = JSON.parse(decodeURIComponent(escape(atob(remoteSDP.value))))
        if(!pc) { log('No peer connection exists. Create offer first.') ; return }
        await pc.setRemoteDescription(remote)
        log('Set remote description — connection should start')
      }catch(e){ log('Bad remote SDP: '+e) }
    }

    // Helpers: copy / clear
    document.getElementById('copyLocal').onclick = ()=>{ localSDP.select(); document.execCommand('copy'); log('Copied local SDP to clipboard') }
    document.getElementById('clearSDP').onclick = ()=>{ localSDP.value=''; remoteSDP.value=''; }

    // default: allow interaction; Play-as lock
    document.getElementById('playAs').onchange = ()=>{
      const v = document.getElementById('playAs').value
      if(v==='white') board.orientation('white')
      else if(v==='black') board.orientation('black')
    }

    // On load: minimal setup
    log('Ready — create an offer to start signalling')

    // Prevent accidental drag when not player's turn — we keep simple: allow any client to move pieces. For stricter control, add turn enforcement and playAs enforcement.

  </script>
</body>
</html>